// Loops Demo - Rhythmic circular patterns with visualization
// Demonstrates JMON's loop system with Plotly.js visualization

console.log('Creating loop demo...');

// Create JMON tracks for loop layers
const bassTrack = {
    label: 'Bass Pattern',
    notes: [
        { pitch: 60, time: 0.0, duration: 1.0, velocity: 0.8 },
        { pitch: 64, time: 1.0, duration: 0.5, velocity: 0.8 },
        { pitch: 67, time: 1.5, duration: 0.5, velocity: 0.8 },
        { pitch: 60, time: 2.0, duration: 1.0, velocity: 0.8 }
    ],
    synth: {
        type: 'Synth',
        options: {
            oscillator: { type: 'sine' },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.5 }
        }
    }
};

const leadTrack = {
    label: 'Lead Pattern',
    notes: [
        { pitch: 72, time: 0.0, duration: 0.25, velocity: 0.9 },
        { pitch: 74, time: 0.25, duration: 0.25, velocity: 0.9 },
        { pitch: 76, time: 0.5, duration: 0.5, velocity: 0.9 },
        { pitch: 77, time: 1.0, duration: 0.25, velocity: 0.9 },
        { pitch: 76, time: 1.25, duration: 0.75, velocity: 0.9 }
    ],
    synth: {
        type: 'PluckSynth',
        options: {
            attackNoise: 1,
            dampening: 4000,
            resonance: 0.7
        }
    }
};

const droneTrack = {
    label: 'Drone Layer',
    notes: [
        { pitch: 48, time: 0.0, duration: 1.0, velocity: 0.6 },
        { pitch: 52, time: 1.0, duration: 1.0, velocity: 0.6 },
        { pitch: 48, time: 2.0, duration: 2.0, velocity: 0.6 }
    ],
    synth: {
        type: 'Synth',
        options: {
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.1, decay: 0.2, sustain: 0.9, release: 1.0 }
        }
    }
};

// Create loop instance directly from JMON tracks
const loop = new jm.generative.loops({
    'Bass Pattern': bassTrack,
    'Lead Pattern': leadTrack,
    'Drone Layer': droneTrack
}, 4, true); // measureLength=4, insertRests=true

console.log('Loop created with', Object.keys(loop.loops).length, 'tracks');

// Get JMON sequences from the loop
const jmonSequences = loop.toJMonSequences();

console.log('Generated sequences:', jmonSequences);
console.log('Sequence count:', jmonSequences.length);
jmonSequences.forEach((seq, index) => {
    console.log(`Sequence ${index}: ${seq.label} - ${seq.notes ? seq.notes.length : 0} notes`);
    if (seq.notes && seq.notes.length > 0) {
        console.log(`  First few notes:`, seq.notes.slice(0, 3).map(n => `pitch=${n.pitch} time=${n.time} dur=${n.duration}`));
    }
});

// Create composition directly from loop sequences 
const loopComposition = {
    format: "jmon",
    version: "1.0.0",
  tempo: 120,
    timeSignature: "4/4",
    keySignature: "C",
    metadata: {
        title: "Loop Composition",
        composer: "Generated by JMON Loops",
        description: "Multi-layered rhythmic patterns in circular motion"
    },
    tracks: jmonSequences
};

// Debug the composition being passed to ABC
console.log('Loop composition for ABC:');
console.log('  Tracks count:', loopComposition.tracks.length);
loopComposition.tracks.forEach((track, i) => {
    console.log(`  Track ${i}: ${track.label} - ${track.notes.length} notes`);
});

// Also create a mixed version for comparison
const allNotes = [];
jmonSequences.forEach((sequence) => {
    sequence.notes.forEach(note => {
        allNotes.push({
            ...note,
            layerName: sequence.label
        });
    });
});
const sortedNotes = allNotes.sort((a, b) => a.time - b.time);

console.log('Generated', sortedNotes.length, 'total notes from loop patterns');
console.log('Created', loopComposition.tracks.length, 'separate tracks:');
loopComposition.tracks.forEach((track, index) => {
    console.log(`  Track ${index + 1}: ${track.label} - ${track.notes.length} notes`);
    if (track.notes.length > 0) {
        console.log(`    First note: pitch=${track.notes[0].pitch}, time=${track.notes[0].time}, duration=${track.notes[0].duration}`);
        console.log(`    All notes:`, track.notes.map(n => `${n.pitch}@${n.time}`).join(', '));
    } else {
        console.log(`    WARNING: No notes generated for ${track.label}`);
    }
});

// Display the player
document.getElementById('player-container').appendChild(
    jm.play(loopComposition, { autoplay: false })
);

// Display the score with multi-track rendering
document.getElementById('score-container').appendChild(
    jm.score(loopComposition, {
        abcOptions: {
            renderMode: 'tracks',
            measuresPerLine: 2,
            lineBreaks: [4, 8]
        }
    })
);

// Create visualization container
const vizContainer = document.createElement('div');
vizContainer.id = 'loop-visualization';
vizContainer.style.cssText = `
    margin: 20px 0;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 5px;
    background: #fafafa;
`;

const vizTitle = document.createElement('h3');
vizTitle.textContent = 'Loop Visualization';
vizTitle.style.cssText = `margin: 0 0 15px 0; color: #333;`;
vizContainer.appendChild(vizTitle);

// Create the actual plot container
const plotContainer = document.createElement('div');
plotContainer.id = 'loop-plot';
plotContainer.style.cssText = `
    width: 100%;
    height: 500px;
    min-height: 400px;
`;
vizContainer.appendChild(plotContainer);

// Add after score container
const scoreContainer = document.getElementById('score-container');
scoreContainer.parentNode.insertBefore(vizContainer, scoreContainer.nextSibling);

// Create visualization if Plotly is available
if (typeof Plotly !== 'undefined' && Plotly !== null) {
    console.log('Plotly.js detected, creating visualization...');
    
    try {
        // Use the loop instance's plot method to create the complete visualization
        const vizResult = await loop.plot(0.25, null, {
            container: 'loop-plot',
            title: 'Multi-Layer Loop Pattern with Duration Arcs'
        });
        
        console.log('Loop visualization created successfully with duration arcs and markers');
        
    } catch (error) {
        console.warn('Error creating loop visualization:', error);
        plotContainer.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                <div style="text-align: center;">
                    <p><strong>Visualization Error</strong></p>
                    <p>Could not create loop plot: ${error.message}</p>
                    <pre style="font-size: 12px; background: #f5f5f5; padding: 10px; border-radius: 4px;">
Loop Tracks:
${Object.entries(loop.loops).map(([name, track], i) => 
`Track ${i+1}: ${track.label}
  - ${track.notes.length} notes
  - Duration: ${Math.max(...track.notes.map(n => n.time + n.duration))} beats`
).join('\n')}
                    </pre>
                </div>
            </div>
        `;
    }
} else {
    console.warn('Plotly.js not available, showing pattern info instead');
    plotContainer.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
            <div style="text-align: center;">
                <p><strong>Plotly.js Required</strong></p>
                <p>Install Plotly.js to see the circular loop visualization</p>
                <div style="text-align: left; background: #f5f5f5; padding: 15px; border-radius: 4px; margin-top: 15px;">
                    <strong>Loop Pattern Summary:</strong><br><br>
                    ${Object.entries(loop.loops).map(([name, track], i) => `
                        <strong>Track ${i+1}: ${track.label}</strong><br>
                        • ${track.notes.length} notes<br>
                        • Duration: ${Math.max(...track.notes.map(n => n.time + n.duration))} beats<br>
                        • Instrument: ${track.synth?.type || 'synth'}<br><br>
                    `).join('')}
                </div>
            </div>
        </div>
    `;
}

// Log loop information
console.log('Loop Configuration:');
Object.entries(loop.loops).forEach(([name, track], index) => {
    console.log(`Track ${index + 1} (${track.label}):`);
    console.log(`  - Notes: ${track.notes.length}`);
    console.log(`  - Duration: ${Math.max(...track.notes.map(n => n.time + n.duration))} beats`);
    console.log(`  - Pitches: [${track.notes.filter(n => n.pitch !== null).map(n => n.pitch).join(', ')}]`);
    console.log(`  - Instrument: ${track.synth?.type || 'synth'}`);
});

// Show the ABC notation with different rendering modes
console.log('ABC Rendering Options:');

// 1. Merged version (default) - all tracks combined chronologically  
const abcMerged = jm.converters.abc(loopComposition, {
    measuresPerLine: 2,
    lineBreaks: [4, 8],
    renderMode: 'merged'
});
console.log('1. Merged tracks (traditional single-staff):', abcMerged);

// 2. Separate tracks version - each loop layer as its own voice/staff  
const abcTracks = jm.converters.abc(loopComposition, {
    measuresPerLine: 2, 
    lineBreaks: [4, 8],
    renderMode: 'tracks'
});
console.log('2. Separate tracks (multi-voice score with track names):', abcTracks);

// 3. Single track example - just the bass pattern
const abcBass = jm.converters.abc(loopComposition, {
    measuresPerLine: 2,
    renderMode: 'single',
    trackIndex: 0
});
console.log('3. Bass pattern only:', abcBass);