<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JMON Studio - Fractal Visualizations</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
        }
        
        .header p {
            margin: 0;
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .fractal-section {
            margin-bottom: 40px;
            border: 2px solid #eee;
            border-radius: 10px;
            padding: 20px;
        }
        
        .fractal-section h2 {
            color: #4a4a4a;
            margin-top: 0;
            font-size: 1.8em;
        }
        
        .fractal-section p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        
        .canvas-item {
            text-align: center;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .canvas-item h3 {
            margin: 0 0 10px 0;
            color: #555;
            font-size: 1.1em;
        }
        
        canvas {
            border: 2px solid #ddd;
            border-radius: 5px;
            background: white;
        }
        
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .controls button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        
        .controls button:hover {
            transform: scale(1.05);
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
            padding: 20px;
        }
        
        .error {
            color: #e74c3c;
            background: #ffeaea;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŒ€ JMON Studio Fractal Visualizations</h1>
            <p>Interactive mathematical patterns for algorithmic music composition</p>
        </div>
        
        <div class="content">
            <div class="fractal-section">
                <h2>ðŸ¦‹ Mandelbrot Set</h2>
                <p>
                    The Mandelbrot set is a fractal mathematical set of points whose boundary forms a distinctive shape. 
                    Each point represents a complex number, and the colors indicate how quickly the iterative formula diverges.
                </p>
                <div class="controls">
                    <button onclick="renderMandelbrot('default')">Default View</button>
                    <button onclick="renderMandelbrot('zoom1')">Zoom Level 1</button>
                    <button onclick="renderMandelbrot('zoom2')">Deep Zoom</button>
                    <button onclick="renderMandelbrot('plasma')">Plasma Colors</button>
                    <button onclick="renderMandelbrot('rainbow')">Rainbow Colors</button>
                </div>
                <div class="canvas-container">
                    <div class="canvas-item">
                        <h3>Interactive Mandelbrot</h3>
                        <canvas id="mandelbrotCanvas" width="400" height="400"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="fractal-section">
                <h2>ðŸ”¬ Cellular Automata</h2>
                <p>
                    Cellular automata are discrete mathematical models used in computational theory, mathematics, and theoretical biology. 
                    Each rule creates unique patterns that can be converted into musical sequences.
                </p>
                <div class="controls">
                    <button onclick="renderCA(30)">Rule 30 (Chaotic)</button>
                    <button onclick="renderCA(150)">Rule 150 (Triangular)</button>
                    <button onclick="renderCA(110)">Rule 110 (Complex)</button>
                    <button onclick="renderCA(54)">Rule 54 (Symmetric)</button>
                </div>
                <div class="canvas-container">
                    <div class="canvas-item">
                        <h3>CA Evolution</h3>
                        <canvas id="caCanvas" width="600" height="300"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="fractal-section">
                <h2>ðŸ“ˆ Logistic Map Bifurcation</h2>
                <p>
                    The logistic map shows how complex, chaotic behavior can arise from simple non-linear dynamical equations. 
                    The bifurcation diagram reveals the transition from order to chaos.
                </p>
                <div class="controls">
                    <button onclick="renderLogistic('full')">Full Diagram</button>
                    <button onclick="renderLogistic('onset')">Onset of Chaos</button>
                    <button onclick="renderLogistic('detail')">Detailed View</button>
                </div>
                <div class="canvas-container">
                    <div class="canvas-item">
                        <h3>Bifurcation Diagram</h3>
                        <canvas id="logisticCanvas" width="600" height="400"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="fractal-section">
                <h2>ðŸŽµ Musical Applications</h2>
                <p>
                    These fractals can be converted into musical sequences using JMON Studio algorithms:
                </p>
                <ul>
                    <li><strong>Mandelbrot:</strong> Diagonal, spiral, or border extraction for melodic sequences</li>
                    <li><strong>Cellular Automata:</strong> Strip extraction for rhythmic patterns and chord progressions</li>
                    <li><strong>Logistic Map:</strong> Chaotic sequences for dynamic musical parameters</li>
                </ul>
                <div class="controls">
                    <button onclick="showMusicalExample()">View Musical Example</button>
                </div>
                <div id="musicalExample" style="display: none; margin-top: 20px; padding: 20px; background: #f0f8ff; border-radius: 8px;">
                    <h3>Example JMON Integration:</h3>
                    <pre><code>// Extract Mandelbrot sequence
const mandelbrot = new Mandelbrot({ width: 20, height: 20 });
const sequence = mandelbrot.extractSequence('diagonal');
const pitches = mandelbrot.mapToScale(sequence);

// Convert to JMON track
const track = notesToTrack(pitches.map((pitch, i) => ({
  pitch, duration: 0.5, time: i * 0.5
})), {
  label: 'mandelbrot-melody',
  synth: { type: 'Synth' }
});</code></pre>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import JMON Studio modules (in a real application, these would be bundled)
        let FractalVisualizer, CellularAutomata, Mandelbrot, LogisticMap;
        
        // Simple implementations for demo purposes
        class SimpleFractalVisualizer {
            static renderMandelbrotCanvas(canvas, xMin, xMax, yMin, yMax, resolution, maxIterations, colorScheme) {
                const ctx = canvas.getContext('2d');
                canvas.width = resolution;
                canvas.height = resolution;
                
                const imageData = ctx.createImageData(resolution, resolution);
                const data = imageData.data;
                
                const dx = (xMax - xMin) / resolution;
                const dy = (yMax - yMin) / resolution;
                
                for (let py = 0; py < resolution; py++) {
                    const y = yMin + py * dy;
                    
                    for (let px = 0; px < resolution; px++) {
                        const x = xMin + px * dx;
                        const iterations = this.mandelbrotIterations(x, y, maxIterations);
                        const normalized = iterations / maxIterations;
                        
                        const color = this.getColorComponents(normalized, colorScheme);
                        const index = (py * resolution + px) * 4;
                        
                        data[index] = color.r;
                        data[index + 1] = color.g;
                        data[index + 2] = color.b;
                        data[index + 3] = 255;
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
                return canvas;
            }
            
            static mandelbrotIterations(x, y, maxIterations) {
                let zx = 0, zy = 0, iteration = 0;
                
                while (zx * zx + zy * zy < 4 && iteration < maxIterations) {
                    const temp = zx * zx - zy * zy + x;
                    zy = 2 * zx * zy + y;
                    zx = temp;
                    iteration++;
                }
                
                return iteration;
            }
            
            static getColorComponents(value, scheme) {
                const normalized = Math.max(0, Math.min(1, value));
                let r, g, b;
                
                switch (scheme) {
                    case 'plasma':
                        r = Math.floor(255 * (0.3 + 0.7 * normalized));
                        g = Math.floor(255 * (0.1 + 0.6 * (1 - normalized)));
                        b = Math.floor(255 * (0.8 + 0.2 * normalized));
                        break;
                    case 'rainbow':
                        const hue = normalized * 360;
                        const rgb = this.hslToRgb(hue / 360, 0.8, 0.5);
                        r = rgb.r; g = rgb.g; b = rgb.b;
                        break;
                    default: // viridis-like
                        r = Math.floor(255 * normalized * 0.3);
                        g = Math.floor(255 * normalized * 0.7);
                        b = Math.floor(255 * (0.2 + 0.8 * normalized));
                }
                
                return { r, g, b };
            }
            
            static hslToRgb(h, s, l) {
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
            
            static renderCACanvas(canvas, history, cellSize = 2) {
                const ctx = canvas.getContext('2d');
                canvas.width = history[0].length * cellSize;
                canvas.height = history.length * cellSize;
                
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = 'black';
                
                for (let y = 0; y < history.length; y++) {
                    for (let x = 0; x < history[y].length; x++) {
                        if (history[y][x] === 1) {
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        }
                    }
                }
                
                return canvas;
            }
            
            static renderLogisticCanvas(canvas, rMin, rMax, rSteps, iterations, skipTransient) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, width, height);
                
                ctx.fillStyle = 'rgba(0, 0, 255, 0.3)';
                
                for (let i = 0; i < rSteps; i++) {
                    const r = rMin + (i / rSteps) * (rMax - rMin);
                    let x = 0.5;
                    
                    // Skip transients
                    for (let j = 0; j < skipTransient; j++) {
                        x = r * x * (1 - x);
                    }
                    
                    // Collect attractors
                    for (let j = 0; j < iterations; j++) {
                        x = r * x * (1 - x);
                        
                        const px = (r - rMin) / (rMax - rMin) * width;
                        const py = height - (x * height);
                        
                        ctx.fillRect(px - 1, py - 1, 2, 2);
                    }
                }
                
                return canvas;
            }
        }
        
        // Simple CA implementation
        class SimpleCA {
            static generateRule(ruleNumber) {
                const binary = ruleNumber.toString(2).padStart(8, '0');
                const rules = {};
                const neighborhoods = ['111', '110', '101', '100', '011', '010', '001', '000'];
                
                for (let i = 0; i < 8; i++) {
                    rules[neighborhoods[i]] = parseInt(binary[i], 10);
                }
                
                return rules;
            }
            
            static generate(width, generations, ruleNumber) {
                const rules = this.generateRule(ruleNumber);
                const history = [];
                
                // Initial state - single cell in center
                let state = new Array(width).fill(0);
                state[Math.floor(width / 2)] = 1;
                history.push([...state]);
                
                for (let gen = 0; gen < generations; gen++) {
                    const newState = new Array(width);
                    
                    for (let i = 0; i < width; i++) {
                        const left = state[(i - 1 + width) % width];
                        const center = state[i];
                        const right = state[(i + 1) % width];
                        
                        const neighborhood = `${left}${center}${right}`;
                        newState[i] = rules[neighborhood] || 0;
                    }
                    
                    state = newState;
                    history.push([...state]);
                }
                
                return history;
            }
        }
        
        // Global functions for buttons
        window.renderMandelbrot = function(type) {
            const canvas = document.getElementById('mandelbrotCanvas');
            
            let xMin, xMax, yMin, yMax, colorScheme = 'viridis';
            
            switch (type) {
                case 'zoom1':
                    xMin = -1.5; xMax = -1.0; yMin = 0; yMax = 0.5;
                    break;
                case 'zoom2':
                    xMin = -1.15; xMax = -1.145; yMin = 0.275; yMax = 0.28;
                    break;
                case 'plasma':
                    xMin = -2.5; xMax = 1.0; yMin = -1.25; yMax = 1.25;
                    colorScheme = 'plasma';
                    break;
                case 'rainbow':
                    xMin = -2.5; xMax = 1.0; yMin = -1.25; yMax = 1.25;
                    colorScheme = 'rainbow';
                    break;
                default:
                    xMin = -2.5; xMax = 1.0; yMin = -1.25; yMax = 1.25;
            }
            
            SimpleFractalVisualizer.renderMandelbrotCanvas(
                canvas, xMin, xMax, yMin, yMax, 400, 100, colorScheme
            );
        };
        
        window.renderCA = function(ruleNumber) {
            const canvas = document.getElementById('caCanvas');
            const history = SimpleCA.generate(300, 150, ruleNumber);
            SimpleFractalVisualizer.renderCACanvas(canvas, history, 2);
        };
        
        window.renderLogistic = function(type) {
            const canvas = document.getElementById('logisticCanvas');
            
            let rMin, rMax;
            switch (type) {
                case 'onset':
                    rMin = 2.8; rMax = 3.6;
                    break;
                case 'detail':
                    rMin = 3.4; rMax = 3.8;
                    break;
                default:
                    rMin = 2.5; rMax = 4.0;
            }
            
            SimpleFractalVisualizer.renderLogisticCanvas(canvas, rMin, rMax, 800, 50, 200);
        };
        
        window.showMusicalExample = function() {
            const example = document.getElementById('musicalExample');
            example.style.display = example.style.display === 'none' ? 'block' : 'none';
        };
        
        // Initialize with default fractals
        setTimeout(() => {
            renderMandelbrot('default');
            renderCA(30);
            renderLogistic('full');
        }, 100);
        
    </script>
</body>
</html>
